diff --git a/Makefile b/Makefile
index f0c47c703..136024670 100644
--- a/Makefile
+++ b/Makefile
@@ -145,6 +145,8 @@ test-integration:
 
 test3-integration:
 	$(GOTEST) --timeout 30m -tags $(BUILD_TAGS),integration,erigon3
+test-tracer:
+	$(GOTEST) --timeout 20s tracers
 
 ## lint:                              run golangci-lint with .golangci.yml config file
 lint:
diff --git a/README.md b/README.md
index c3a3b1063..5e8d7c766 100644
--- a/README.md
+++ b/README.md
@@ -7,7 +7,7 @@ Erigon is an implementation of Ethereum (execution client), on the efficiency fr
 ![Coverage](https://gist.githubusercontent.com/revitteth/ee38e9beb22353eef6b88f2ad6ed7aa9/raw/badge.svg)
 
 ![Hive](https://gist.githubusercontent.com/revitteth/dc492845ba6eb694e6c7279224634b20/raw/badge.svg)
-
+ 
 <!--ts-->
 
 - [System Requirements](#system-requirements)
diff --git a/cmd/rpcdaemon/commands/eth_callMany.go b/cmd/rpcdaemon/commands/eth_callMany.go
index b445eb200..82d0e1b28 100644
--- a/cmd/rpcdaemon/commands/eth_callMany.go
+++ b/cmd/rpcdaemon/commands/eth_callMany.go
@@ -36,6 +36,7 @@ type BlockOverrides struct {
 type Bundle struct {
 	Transactions  []rpcapi.CallArgs
 	BlockOverride BlockOverrides
+	CustomTracer  vm.Tracer
 }
 
 type StateContext struct {
@@ -80,6 +81,7 @@ func (api *APIImpl) CallMany(ctx context.Context, bundles []Bundle, simulateCont
 		baseFee            uint256.Int
 	)
 
+	fmt.Println("Inside implementation, lets put a tracer here")
 	overrideBlockHash = make(map[uint64]common.Hash)
 	tx, err := api.db.BeginRo(ctx)
 	if err != nil {
diff --git a/cmd/rpcdaemon/commands/eth_callMany_test.go b/cmd/rpcdaemon/commands/eth_callMany_test.go
index eeb1b0be2..54b3f73fe 100644
--- a/cmd/rpcdaemon/commands/eth_callMany_test.go
+++ b/cmd/rpcdaemon/commands/eth_callMany_test.go
@@ -3,6 +3,7 @@ package commands
 import (
 	"context"
 	"encoding/hex"
+	"encoding/json"
 	"fmt"
 	"math/big"
 	"strconv"
@@ -15,6 +16,7 @@ import (
 	"github.com/ledgerwatch/erigon/common/hexutil"
 	"github.com/ledgerwatch/erigon/core"
 	"github.com/ledgerwatch/erigon/crypto"
+	"github.com/ledgerwatch/erigon/eth/tracers"
 	"github.com/ledgerwatch/erigon/internal/ethapi"
 	"github.com/ledgerwatch/erigon/params"
 	"github.com/ledgerwatch/erigon/rpc"
@@ -30,6 +32,11 @@ import (
 // test 2 bundles
 // check balance of addr1 and addr 2 at the end of block and interblock
 
+func PrintJSON(obj interface{}) {
+	bytes, _ := json.MarshalIndent(obj, "\t", "\t")
+	fmt.Println(string(bytes))
+}
+
 func TestCallMany(t *testing.T) {
 	var (
 		key, _   = crypto.HexToECDSA("b71c71a67e1177ad4e901695e1b4b9ee17ae16c6668d313eac2f96dbcda3f291")
@@ -100,11 +107,22 @@ func TestCallMany(t *testing.T) {
 
 	timeout := int64(50000)
 	txIndex := -1
+
+	trc := `{
+		retVal: [],
+		step: function(log,db) {this.retVal.push(log.getPC() + ":X:X:X:" + log.op.toString())},'
+		fault: function(log,db) {this.retVal.push("FAULT: " + JSON.stringify(log))},
+		result: function(ctx,db) {return this.retVal}
+		}`
+	tracer, err := tracers.New(trc, &tracers.Context{})
+
 	res, err := api.CallMany(ctx, []Bundle{{
+		CustomTracer: tracer,
 		Transactions: []ethapi.CallArgs{callArgAddr1, callArgAddr2}}}, StateContext{BlockNumber: rpc.BlockNumberOrHashWithNumber(rpc.LatestBlockNumber), TransactionIndex: &txIndex}, nil, &timeout)
 	if err != nil {
 		t.Errorf("eth_callMany: %v", err)
 	}
+	fmt.Printf("ethcallmany trace: %v", res)
 
 	// parse the results and do balance checks
 	addr1CalRet := fmt.Sprintf("%v", res[0][0]["value"])[2:]
@@ -149,6 +167,8 @@ func TestCallMany(t *testing.T) {
 		t.Errorf("%v", err)
 	}
 
+	PrintJSON(res)
+
 	addr1CalRet = fmt.Sprintf("%v", res[0][1]["value"])[2:]
 	addr2CalRet = fmt.Sprintf("%v", res[0][2]["value"])[2:]
 
diff --git a/cmd/rpcdaemon/commands/trace_adhoc.go b/cmd/rpcdaemon/commands/trace_adhoc.go
index ce1371125..92a3e6ec9 100644
--- a/cmd/rpcdaemon/commands/trace_adhoc.go
+++ b/cmd/rpcdaemon/commands/trace_adhoc.go
@@ -21,11 +21,13 @@ import (
 	"github.com/ledgerwatch/erigon/core/types"
 	"github.com/ledgerwatch/erigon/core/types/accounts"
 	"github.com/ledgerwatch/erigon/core/vm"
+	"github.com/ledgerwatch/erigon/eth/tracers"
 	"github.com/ledgerwatch/erigon/rpc"
 	"github.com/ledgerwatch/erigon/turbo/rpchelper"
 	"github.com/ledgerwatch/erigon/turbo/shards"
 	"github.com/ledgerwatch/erigon/turbo/transactions"
 	"github.com/ledgerwatch/log/v3"
+	"github.com/samber/lo"
 )
 
 const (
@@ -63,6 +65,7 @@ type TraceCallResult struct {
 	Trace           []*ParityTrace                       `json:"trace"`
 	VmTrace         *VmTrace                             `json:"vmTrace"`
 	TransactionHash *common.Hash                         `json:"transactionHash,omitempty"`
+	AccessedStorage map[common.Address][]common.Hash     `json:"accessedStorage"`
 }
 
 // StateDiffAccount is the part of `trace_call` response that is under "stateDiff" tag
@@ -71,6 +74,7 @@ type StateDiffAccount struct {
 	Code    interface{}                            `json:"code"`
 	Nonce   interface{}                            `json:"nonce"`
 	Storage map[common.Hash]map[string]interface{} `json:"storage"`
+	Reads   []common.Hash                          `json:"reads"`
 }
 
 type StateDiffBalance struct {
@@ -549,6 +553,7 @@ func (ot *OeTracer) CaptureSelfDestruct(from common.Address, to common.Address,
 }
 
 func (ot *OeTracer) CaptureAccountRead(account common.Address) error {
+	// ot.r.StateDiff
 	return nil
 }
 func (ot *OeTracer) CaptureAccountWrite(account common.Address) error {
@@ -596,6 +601,18 @@ func (sd *StateDiff) WriteAccountStorage(address common.Address, incarnation uin
 	return nil
 }
 
+func (sd *StateDiff) ReadAccountStorage(address common.Address, incarnation uint64, key *common.Hash) error {
+	log.Debug("Called trace_adhoc.ReadAccountStoage")
+	accountDiff := sd.sdMap[address]
+	if accountDiff == nil {
+		accountDiff = &StateDiffAccount{Storage: make(map[common.Hash]map[string]interface{})}
+		sd.sdMap[address] = accountDiff
+	}
+
+	// accountDiff.Reads = append(accountDiff.Reads, common.HexToAddress("0xf97e180c050e5ab072211ad2c213eb5aee4df134"))
+	return nil
+}
+
 func (sd *StateDiff) CreateContract(address common.Address) error {
 	if _, ok := sd.sdMap[address]; !ok {
 		sd.sdMap[address] = &StateDiffAccount{Storage: make(map[common.Hash]map[string]interface{})}
@@ -1160,6 +1177,18 @@ func (api *TraceAPIImpl) doCallMany(ctx context.Context, dbtx kv.Tx, msgs []type
 			vmConfig.Tracer = &ot
 		}
 
+		trc := `{
+			retVal: [],
+			step: function(log,db) {this.retVal.push(log.getPC() + ":X:X:X:" + log.op.toString())},
+			fault: function(log,db) {this.retVal.push("FAULT: " + JSON.stringify(log))},
+			result: function(ctx,db) {return this.retVal}
+			}`
+		tracer, err := tracers.New(trc, &tracers.Context{})
+		if err != nil {
+			panic(err)
+		}
+		vmConfig.Tracer = tracer
+
 		// Get a new instance of the EVM.
 		blockCtx, txCtx := transactions.GetEvmContext(msg, header, parentNrOrHash.RequireCanonical, dbtx, api._blockReader)
 		if useParent {
@@ -1212,13 +1241,21 @@ func (api *TraceAPIImpl) doCallMany(ctx context.Context, dbtx kv.Tx, msgs []type
 		if !traceTypeTrace {
 			traceResult.Trace = []*ParityTrace{}
 		}
+		stateObjs := ibs.GetStateObjects()
+		for _, accessObject := range *stateObjs {
+
+			traceResult.AccessedStorage = lo.Assign(traceResult.AccessedStorage, accessObject.GetAccessedSlots())
+
+		}
 		results = append(results, traceResult)
 		// When txIndexNeeded is not -1, we are tracing specific transaction in the block and not the entire block, so we stop after we've traced
 		// the required transaction
 		if txIndexNeeded != -1 && txIndex == txIndexNeeded {
 			break
 		}
+
 	}
+
 	return results, nil
 }
 
diff --git a/cmd/rpcdaemon/commands/tracing.go b/cmd/rpcdaemon/commands/tracing.go
index 7ff0707b4..4d49e5548 100644
--- a/cmd/rpcdaemon/commands/tracing.go
+++ b/cmd/rpcdaemon/commands/tracing.go
@@ -362,7 +362,11 @@ func (api *PrivateDebugAPIImpl) TraceCallMany(ctx context.Context, bundles []Bun
 		BaseFee:     &baseFee,
 	}
 
-	evm = vm.NewEVM(blockCtx, txCtx, st, chainConfig, vm.Config{Debug: false})
+	tracer, err := tracers.New(*config.Tracer, &tracers.Context{
+		TxHash: txCtx.TxHash,
+	})
+
+	evm = vm.NewEVM(blockCtx, txCtx, st, chainConfig, vm.Config{Debug: false, Tracer: tracer})
 
 	// Setup the gas pool (also for unmetered requests)
 	// and apply the message.
diff --git a/core/state/cached_reader.go b/core/state/cached_reader.go
index 36a9c65e7..20b07cb0b 100644
--- a/core/state/cached_reader.go
+++ b/core/state/cached_reader.go
@@ -2,6 +2,7 @@ package state
 
 import (
 	"bytes"
+	"fmt"
 
 	"github.com/ledgerwatch/erigon/common"
 	"github.com/ledgerwatch/erigon/core/types/accounts"
@@ -44,7 +45,9 @@ func (cr *CachedReader) ReadAccountStorage(address common.Address, incarnation u
 	if s, ok := cr.cache.GetStorage(addrBytes, incarnation, key.Bytes()); ok {
 		return s, nil
 	}
+	fmt.Printf("CR: Accessing storage %x -> %x \n", address, key)
 	v, err := cr.r.ReadAccountStorage(address, incarnation, key)
+
 	if err != nil {
 		return nil, err
 	}
diff --git a/core/state/cached_reader2.go b/core/state/cached_reader2.go
index bb438a618..7c9505389 100644
--- a/core/state/cached_reader2.go
+++ b/core/state/cached_reader2.go
@@ -3,6 +3,7 @@ package state
 import (
 	"bytes"
 	"encoding/binary"
+	"fmt"
 
 	"github.com/ledgerwatch/erigon-lib/kv"
 	"github.com/ledgerwatch/erigon-lib/kv/kvcache"
@@ -40,6 +41,8 @@ func (r *CachedReader2) ReadAccountData(address common.Address) (*accounts.Accou
 }
 
 func (r *CachedReader2) ReadAccountStorage(address common.Address, incarnation uint64, key *common.Hash) ([]byte, error) {
+	fmt.Printf("CR2: Accessing storage %x -> %x \n", address, key)
+
 	compositeKey := dbutils.PlainGenerateCompositeStorageKey(address.Bytes(), incarnation, key.Bytes())
 	enc, err := r.cache.Get(compositeKey)
 	if err != nil {
diff --git a/core/state/intra_block_state.go b/core/state/intra_block_state.go
index a5091e22d..8e46f2810 100644
--- a/core/state/intra_block_state.go
+++ b/core/state/intra_block_state.go
@@ -105,6 +105,9 @@ func New(stateReader StateReader) *IntraBlockState {
 	}
 }
 
+func (sdb *IntraBlockState) GetStateObjects() *map[common.Address]*stateObject {
+	return &sdb.stateObjects
+}
 func (sdb *IntraBlockState) SetTracer(tracer StateTracer) {
 	sdb.tracer = tracer
 }
diff --git a/core/state/state_object.go b/core/state/state_object.go
index ffdcde3e7..bee2cfefb 100644
--- a/core/state/state_object.go
+++ b/core/state/state_object.go
@@ -64,11 +64,11 @@ func (s Storage) Copy() Storage {
 // First you need to obtain a state object.
 // Account values can be accessed and modified through the object.
 type stateObject struct {
-	address  common.Address
-	data     accounts.Account
-	original accounts.Account
-	db       *IntraBlockState
-
+	address       common.Address
+	data          accounts.Account
+	original      accounts.Account
+	db            *IntraBlockState
+	accessedSlots map[common.Address]map[common.Hash]uint
 	// Write caches.
 	//trie Trie // storage trie, which becomes non-nil on first access
 	code Code // contract bytecode, which gets set when code is loaded
@@ -103,6 +103,7 @@ func newObject(db *IntraBlockState, address common.Address, data, original *acco
 		originStorage:      make(Storage),
 		blockOriginStorage: make(Storage),
 		dirtyStorage:       make(Storage),
+		accessedSlots:      make(map[common.Address]map[common.Hash]uint),
 	}
 	so.data.Copy(data)
 	if !so.data.Initialised {
@@ -120,6 +121,18 @@ func newObject(db *IntraBlockState, address common.Address, data, original *acco
 	return &so
 }
 
+func (so *stateObject) GetAccessedSlots() map[common.Address][]common.Hash {
+
+	out := make(map[common.Address][]common.Hash)
+	for addr := range so.accessedSlots {
+		out[addr] = make([]common.Hash, 0)
+		for key, _ := range so.accessedSlots[addr] {
+			out[addr] = append(out[addr], key)
+		}
+	}
+	return out
+}
+
 // EncodeRLP implements rlp.Encoder.
 func (so *stateObject) EncodeRLP(w io.Writer) error {
 	return rlp.Encode(w, so.data)
@@ -160,7 +173,12 @@ func (so *stateObject) GetState(key *common.Hash, out *uint256.Int) {
 		return
 	}
 	// Otherwise return the entry's original value
+	if so.accessedSlots[so.address] == nil {
+		so.accessedSlots[so.address] = make(map[common.Hash]uint)
+	}
+	so.accessedSlots[so.address][*key] = 1
 	so.GetCommittedState(key, out)
+
 }
 
 // GetCommittedState retrieves a value from the committed account storage trie.
diff --git a/core/vm/instructions.go b/core/vm/instructions.go
index c0d352c5b..557a5a3e0 100644
--- a/core/vm/instructions.go
+++ b/core/vm/instructions.go
@@ -866,6 +866,7 @@ func makeLog(size int) executionFunc {
 	return func(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) {
 		topics := make([]common.Hash, size)
 		stack := scope.Stack
+		fmt.Printf("Making log with stack top: %v\n", scope.Stack.Data[0])
 		mStart, mSize := stack.Pop(), stack.Pop()
 		for i := 0; i < size; i++ {
 			addr := stack.Pop()
diff --git a/eth/tracers/tracer_test.go b/eth/tracers/tracer_test.go
index fb22ed097..3023a0d81 100644
--- a/eth/tracers/tracer_test.go
+++ b/eth/tracers/tracer_test.go
@@ -19,6 +19,7 @@ package tracers
 import (
 	"encoding/json"
 	"errors"
+	"fmt"
 	"math/big"
 	"testing"
 	"time"
@@ -80,12 +81,27 @@ func runTrace(tracer *Tracer, vmctx *vmContext) (json.RawMessage, error) {
 	return tracer.GetResult()
 }
 
+func TestCustom(t *testing.T) {
+	code := "{stack: [], step: function(log) { this.stack.push([log.op, log.stack]); }, fault: function() {}, result: function() { return [2]; } }"
+
+	tracer, err := New(code, new(Context))
+	ctx := &vmContext{blockCtx: vm.BlockContext{
+		BlockNumber: 1500,
+	}, txCtx: vm.TxContext{GasPrice: big.NewInt(100000)}}
+	if err != nil {
+		t.Fatal(err)
+	}
+	ret, err := runTrace(tracer, ctx)
+	fmt.Printf("Lets go: %v", ret)
+}
+
 func TestTracer(t *testing.T) {
 	execTracer := func(code string) ([]byte, string) {
 		t.Helper()
 		ctx := &vmContext{blockCtx: vm.BlockContext{
 			BlockNumber: 1,
 		}, txCtx: vm.TxContext{GasPrice: big.NewInt(100000)}}
+
 		tracer, err := New(code, new(Context))
 		if err != nil {
 			t.Fatal(err)
diff --git a/go.mod b/go.mod
index 3bcb044b6..f8ba88afa 100644
--- a/go.mod
+++ b/go.mod
@@ -152,6 +152,7 @@ require (
 	github.com/prometheus/common v0.37.0 // indirect
 	github.com/prometheus/procfs v0.8.0 // indirect
 	github.com/raulk/go-watchdog v1.3.0 // indirect
+	github.com/samber/lo v1.33.0 // indirect
 	github.com/spacemonkeygo/spacelog v0.0.0-20180420211403-2296661a0572 // indirect
 	github.com/whyrusleeping/timecache v0.0.0-20160911033111-cfcb2f1abfee // indirect
 	go.opentelemetry.io/otel v1.8.0 // indirect
diff --git a/go.sum b/go.sum
index 2a2d2fb99..6ddbfedbe 100644
--- a/go.sum
+++ b/go.sum
@@ -871,6 +871,8 @@ github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQD
 github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
 github.com/ryszard/goskiplist v0.0.0-20150312221310-2dfbae5fcf46 h1:GHRpF1pTW19a8tTFrMLUcfWwyC0pnifVo2ClaLq+hP8=
 github.com/ryszard/goskiplist v0.0.0-20150312221310-2dfbae5fcf46/go.mod h1:uAQ5PCi+MFsC7HjREoAz1BU+Mq60+05gifQSsHSDG/8=
+github.com/samber/lo v1.33.0 h1:2aKucr+rQV6gHpY3bpeZu69uYoQOzVhGT3J22Op6Cjk=
+github.com/samber/lo v1.33.0/go.mod h1:HLeWcJRRyLKp3+/XBJvOrerCQn9mhdKMHyd7IRlgeQ8=
 github.com/samuel/go-zookeeper v0.0.0-20190923202752-2cc03de413da/go.mod h1:gi+0XIa01GRL2eRQVjQkKGqKF3SF9vZR/HnPullcV2E=
 github.com/sclevine/agouti v3.0.0+incompatible/go.mod h1:b4WX9W9L1sfQKXeJf1mUTLZKJ48R1S7H23Ji7oFO5Bw=
 github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=
